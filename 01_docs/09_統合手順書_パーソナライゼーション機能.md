# パーソナライゼーション機能 統合手順書

## 📋 ドキュメント情報
- **作成日**: 2025-10-13
- **バージョン**: 1.0
- **対象ブランチ**: feature/improve-task-personalization

---

## 🎯 統合の目的

基本タスク生成（Step 1）の後に、追加質問を通じてユーザー情報を深堀りし、個別タスク生成（Step 2）とTips収集（Step 3）を実行する新しいフローをmain.pyに統合します。

---

## 📁 実装済みモジュール

以下のモジュールを実装しました：

1. **question_generator.py** - 追加質問生成・管理
2. **conversation_flow_manager.py** - 会話状態管理
3. **task_personalizer.py** - 個別タスク生成（Step 2）
4. **task_enhancer.py** - Tips収集・拡張（Step 3）
5. **001_add_personalization_tables.sql** - DBスキーマ拡張

---

## 🔄 新しいフロー概要

```
┌─────────────────────────────────────────────────┐
│  プロフィール収集完了                            │
│  (relationship, prefecture, municipality, death_date) │
└──────────────────┬──────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────┐
│  Step 1: 基本タスク生成（既存）                  │
│  → generate_basic_tasks() in task_generator.py  │
│  → Cloud Tasks経由で非同期実行                  │
└──────────────────┬──────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────┐
│  基本タスク生成完了通知                          │
│  + 追加質問を生成                               │
│  → generate_follow_up_questions()               │
└──────────────────┬──────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────┐
│  ユーザーが追加質問に回答                        │
│  → save_answer()                                │
│  → すべて回答完了チェック                        │
└──────────────────┬──────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────┐
│  Step 2: 個別タスク生成                          │
│  → generate_personalized_tasks()                │
│  → Cloud Tasks経由で非同期実行（推奨）          │
└──────────────────┬──────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────┐
│  Step 3: Tips収集・拡張                          │
│  → enhance_tasks_with_tips()                    │
│  → Cloud Tasks経由でバックグラウンド実行        │
└─────────────────────────────────────────────────┘
```

---

## 🛠️ 統合手順

### 手順1: データベースマイグレーション実行

```bash
# マイグレーションSQLを実行
psql -h <DB_HOST> -U <DB_USER> -d <DB_NAME> -f 02_src/db/migrations/001_add_personalization_tables.sql
```

または、Cloud SQL Proxyを使用：

```bash
cloud_sql_proxy -instances=<CONNECTION_NAME>=tcp:5432 &
psql -h 127.0.0.1 -U <DB_USER> -d <DB_NAME> -f 02_src/db/migrations/001_add_personalization_tables.sql
```

### 手順2: `generate_tasks_worker` の修正

`main.py` の `generate_tasks_worker` 関数を以下のように修正：

```python
@functions_framework.http
def generate_tasks_worker(request: Request):
    """
    非同期タスク生成ワーカー（Step 1: 基本タスク）

    Cloud Tasksから呼び出され、基本タスクを生成してPush通知する
    完了後、追加質問を生成してユーザーに送信
    """
    from task_generator import generate_basic_tasks, get_task_summary_message
    from question_generator import generate_follow_up_questions, format_question_for_line
    from conversation_flow_manager import ConversationFlowManager

    try:
        request_json = request.get_json(silent=True)
        if not request_json:
            return jsonify({"error": "Invalid request body"}), 400

        user_id = request_json.get('user_id')
        line_user_id = request_json.get('line_user_id')

        if not user_id or not line_user_id:
            return jsonify({"error": "user_id and line_user_id are required"}), 400

        print(f"🔄 Step 1: 基本タスク生成開始: user_id={user_id}")

        engine = get_db_engine()

        # 会話フロー管理初期化
        with engine.connect() as conn:
            flow_manager = ConversationFlowManager(conn)
            flow_manager.set_task_generation_step_status(user_id, 'basic', 'in_progress')

        # ユーザープロフィールを取得
        with engine.connect() as conn:
            profile_data = conn.execute(
                sqlalchemy.text(
                    """
                    SELECT relationship, prefecture, municipality, death_date
                    FROM user_profiles
                    WHERE user_id = :user_id
                    """
                ),
                {"user_id": user_id}
            ).fetchone()

            if not profile_data:
                print(f"⚠️ ユーザープロフィールが見つかりません: {user_id}")
                return jsonify({"error": "User profile not found"}), 404

            profile = {
                'relationship': profile_data[0],
                'prefecture': profile_data[1],
                'municipality': profile_data[2],
                'death_date': profile_data[3]
            }

        # Step 1: 基本タスク生成
        with engine.connect() as conn:
            tasks = generate_basic_tasks(user_id, profile, conn)

        print(f"✅ Step 1完了: {len(tasks)}件の基本タスクを生成")

        # Step 1完了をマーク
        with engine.connect() as conn:
            flow_manager = ConversationFlowManager(conn)
            flow_manager.set_task_generation_step_status(
                user_id, 'basic', 'completed',
                metadata={'task_count': len(tasks)}
            )

        # 追加質問を生成
        with engine.connect() as conn:
            questions = generate_follow_up_questions(user_id, profile, tasks, conn)

        print(f"✅ 追加質問生成完了: {len(questions)}件")

        # サマリーメッセージ + 追加質問
        municipality = profile['municipality']
        summary_message = get_task_summary_message(tasks, municipality)

        # 追加質問の最初の質問を取得
        with engine.connect() as conn:
            first_question_data = conn.execute(
                sqlalchemy.text(
                    """
                    SELECT question_text, question_type, options
                    FROM follow_up_questions
                    WHERE user_id = :user_id AND is_answered = false
                    ORDER BY display_order
                    LIMIT 1
                    """
                ),
                {'user_id': user_id}
            ).fetchone()

        # LINE Push API で通知
        configuration = get_configuration()
        with ApiClient(configuration) as api_client:
            line_bot_api = MessagingApi(api_client)

            messages = [TextMessage(text=summary_message)]

            if first_question_data:
                question_obj = {
                    'question_text': first_question_data[0],
                    'question_type': first_question_data[1],
                    'options': first_question_data[2]
                }
                question_message = format_question_for_line(question_obj)

                # Quick Replyで質問
                quick_reply = QuickReply(
                    items=[
                        QuickReplyItem(action=MessageAction(label="はい", text="はい")),
                        QuickReplyItem(action=MessageAction(label="いいえ", text="いいえ"))
                    ]
                )

                messages.append(
                    TextMessage(
                        text=f"\n\n📝 より詳細なタスクを生成するため、いくつか質問させてください。\n\n{question_message}",
                        quick_reply=quick_reply
                    )
                )

            line_bot_api.push_message(
                PushMessageRequest(
                    to=line_user_id,
                    messages=messages
                )
            )

        print(f"📤 Push通知送信完了: line_user_id={line_user_id}")

        # 会話状態を「追加質問待ち」に設定
        with engine.connect() as conn:
            flow_manager = ConversationFlowManager(conn)
            flow_manager.set_state(
                user_id,
                'awaiting_follow_up_answers',
                {'current_question_index': 0}
            )

        return jsonify({
            "status": "success",
            "user_id": user_id,
            "basic_tasks_count": len(tasks),
            "follow_up_questions_count": len(questions)
        }), 200

    except Exception as e:
        print(f"❌ タスク生成エラー: {e}")
        import traceback
        traceback.print_exc()

        # エラー時はStep 1をfailedにマーク
        if 'user_id' in locals():
            with engine.connect() as conn:
                flow_manager = ConversationFlowManager(conn)
                flow_manager.set_task_generation_step_status(
                    user_id, 'basic', 'failed',
                    error_message=str(e)
                )

        # エラー通知
        try:
            if 'line_user_id' in locals() and line_user_id:
                configuration = get_configuration()
                with ApiClient(configuration) as api_client:
                    line_bot_api = MessagingApi(api_client)
                    line_bot_api.push_message(
                        PushMessageRequest(
                            to=line_user_id,
                            messages=[TextMessage(
                                text="⚠️ タスク生成中にエラーが発生しました。\n\nお手数ですが、しばらく時間をおいて再度プロフィール登録をお試しください。"
                            )]
                        )
                    )
        except:
            pass

        return jsonify({"error": str(e)}), 500
```

### 手順3: `handle_message` に追加質問回答処理を追加

`process_profile_collection` 関数内で追加質問への回答を処理：

```python
def process_profile_collection(user_id, line_user_id, message, relationship, prefecture, municipality, death_date):
    """プロフィール収集処理"""
    engine = get_db_engine()

    from conversation_flow_manager import ConversationFlowManager
    from question_generator import (
        get_unanswered_questions,
        save_answer,
        check_all_questions_answered,
        format_question_for_line
    )

    with engine.connect() as conn:
        flow_manager = ConversationFlowManager(conn)
        current_state = flow_manager.get_current_state(user_id)

        # 追加質問回答待ち状態の場合
        if current_state == 'awaiting_follow_up_answers':
            # 未回答の質問を取得
            questions = get_unanswered_questions(user_id, conn)

            if questions:
                # 最初の未回答質問に対する回答として保存
                first_question = questions[0]
                save_answer(user_id, first_question['question_key'], message, conn)

                # まだ未回答の質問があるか確認
                remaining_questions = get_unanswered_questions(user_id, conn)

                if remaining_questions:
                    # 次の質問を送信
                    next_question = remaining_questions[0]
                    question_message = format_question_for_line(next_question)

                    quick_reply = QuickReply(
                        items=[
                            QuickReplyItem(action=MessageAction(label="はい", text="はい")),
                            QuickReplyItem(action=MessageAction(label="いいえ", text="いいえ"))
                        ]
                    )

                    return {
                        "type": "text_with_quick_reply",
                        "text": question_message,
                        "quick_reply": quick_reply
                    }
                else:
                    # すべての質問に回答完了
                    # Step 2: 個別タスク生成を開始
                    flow_manager.clear_state(user_id, 'awaiting_follow_up_answers')

                    # Cloud Tasksに個別タスク生成ジョブを投入
                    enqueue_personalized_task_generation(user_id, line_user_id)

                    return """✅ 質問へのご回答ありがとうございました！

🤖 あなたの状況に特化した追加タスクを生成中です...

⏱️ 完了したら通知でお知らせします。"""

    # 既存のプロフィール収集フロー（変更なし）
    # ...（ここに既存のコードを配置）
```

### 手順4: 個別タスク生成ワーカーを追加

新しいCloud Function / エンドポイントを追加：

```python
@functions_framework.http
def personalized_tasks_worker(request: Request):
    """
    Step 2: 個別タスク生成ワーカー

    Cloud Tasksから呼び出され、追加質問の回答に基づいて
    個別タスクを生成する
    """
    from task_personalizer import generate_personalized_tasks
    from conversation_flow_manager import ConversationFlowManager
    from question_generator import get_user_answers

    try:
        request_json = request.get_json(silent=True)
        if not request_json:
            return jsonify({"error": "Invalid request body"}), 400

        user_id = request_json.get('user_id')
        line_user_id = request_json.get('line_user_id')

        if not user_id or not line_user_id:
            return jsonify({"error": "user_id and line_user_id are required"}), 400

        print(f"🔄 Step 2: 個別タスク生成開始: user_id={user_id}")

        engine = get_db_engine()

        # Step 2開始をマーク
        with engine.connect() as conn:
            flow_manager = ConversationFlowManager(conn)
            flow_manager.set_task_generation_step_status(user_id, 'personalized', 'in_progress')

        # プロフィールと追加回答を取得
        with engine.connect() as conn:
            profile_data = conn.execute(
                sqlalchemy.text(
                    """
                    SELECT relationship, prefecture, municipality, death_date
                    FROM user_profiles
                    WHERE user_id = :user_id
                    """
                ),
                {"user_id": user_id}
            ).fetchone()

            profile = {
                'relationship': profile_data[0],
                'prefecture': profile_data[1],
                'municipality': profile_data[2],
                'death_date': profile_data[3]
            }

            additional_answers = get_user_answers(user_id, conn)

        # Step 2: 個別タスク生成
        with engine.connect() as conn:
            personalized_tasks = generate_personalized_tasks(
                user_id, profile, additional_answers, conn
            )

        print(f"✅ Step 2完了: {len(personalized_tasks)}件の個別タスクを生成")

        # Step 2完了をマーク
        with engine.connect() as conn:
            flow_manager = ConversationFlowManager(conn)
            flow_manager.set_task_generation_step_status(
                user_id, 'personalized', 'completed',
                metadata={'task_count': len(personalized_tasks)}
            )

        # LINE通知
        configuration = get_configuration()
        with ApiClient(configuration) as api_client:
            line_bot_api = MessagingApi(api_client)
            line_bot_api.push_message(
                PushMessageRequest(
                    to=line_user_id,
                    messages=[TextMessage(
                        text=f"✅ あなた専用の追加タスクを{len(personalized_tasks)}件生成しました！\n\n「タスク」と送信して確認してください。"
                    )]
                )
            )

        # Step 3: Tips収集をバックグラウンドで開始
        enqueue_tips_enhancement(user_id, line_user_id)

        return jsonify({
            "status": "success",
            "user_id": user_id,
            "personalized_tasks_count": len(personalized_tasks)
        }), 200

    except Exception as e:
        print(f"❌ 個別タスク生成エラー: {e}")
        import traceback
        traceback.print_exc()

        if 'user_id' in locals():
            with engine.connect() as conn:
                flow_manager = ConversationFlowManager(conn)
                flow_manager.set_task_generation_step_status(
                    user_id, 'personalized', 'failed',
                    error_message=str(e)
                )

        return jsonify({"error": str(e)}), 500


@functions_framework.http
def tips_enhancement_worker(request: Request):
    """
    Step 3: Tips収集・拡張ワーカー

    Cloud Tasksから呼び出され、既存タスクにSNS・ブログから
    収集したTipsを追加する
    """
    from task_enhancer import enhance_tasks_with_tips, generate_general_tips_task
    from conversation_flow_manager import ConversationFlowManager

    try:
        request_json = request.get_json(silent=True)
        if not request_json:
            return jsonify({"error": "Invalid request body"}), 400

        user_id = request_json.get('user_id')
        line_user_id = request_json.get('line_user_id')

        if not user_id or not line_user_id:
            return jsonify({"error": "user_id and line_user_id are required"}), 400

        print(f"🔄 Step 3: Tips収集開始: user_id={user_id}")

        engine = get_db_engine()

        # Step 3開始をマーク
        with engine.connect() as conn:
            flow_manager = ConversationFlowManager(conn)
            flow_manager.set_task_generation_step_status(user_id, 'enhanced', 'in_progress')

        # プロフィール取得
        with engine.connect() as conn:
            profile_data = conn.execute(
                sqlalchemy.text(
                    "SELECT relationship, prefecture, municipality, death_date FROM user_profiles WHERE user_id = :user_id"
                ),
                {"user_id": user_id}
            ).fetchone()

            profile = {
                'relationship': profile_data[0],
                'prefecture': profile_data[1],
                'municipality': profile_data[2],
                'death_date': profile_data[3]
            }

        # Step 3: Tips収集・拡張
        with engine.connect() as conn:
            stats = enhance_tasks_with_tips(user_id, conn)
            generate_general_tips_task(user_id, profile, conn)

        print(f"✅ Step 3完了: {stats['enhanced_count']}件のタスクに{stats['new_tips_count']}個のTipsを追加")

        # Step 3完了をマーク
        with engine.connect() as conn:
            flow_manager = ConversationFlowManager(conn)
            flow_manager.set_task_generation_step_status(
                user_id, 'enhanced', 'completed',
                metadata=stats
            )

        # LINE通知
        configuration = get_configuration()
        with ApiClient(configuration) as api_client:
            line_bot_api = MessagingApi(api_client)
            line_bot_api.push_message(
                PushMessageRequest(
                    to=line_user_id,
                    messages=[TextMessage(
                        text=f"💡 タスクに実用的なTipsを追加しました！\n\n体験談や裏技を参考にして、スムーズに手続きを進めてください。"
                    )]
                )
            )

        return jsonify({
            "status": "success",
            "user_id": user_id,
            "enhanced_count": stats['enhanced_count'],
            "new_tips_count": stats['new_tips_count']
        }), 200

    except Exception as e:
        print(f"❌ Tips収集エラー: {e}")
        import traceback
        traceback.print_exc()

        if 'user_id' in locals():
            with engine.connect() as conn:
                flow_manager = ConversationFlowManager(conn)
                flow_manager.set_task_generation_step_status(
                    user_id, 'enhanced', 'failed',
                    error_message=str(e)
                )

        return jsonify({"error": str(e)}), 500
```

### 手順5: Cloud Tasksエンキュー関数を追加

```python
def enqueue_personalized_task_generation(user_id: str, line_user_id: str):
    """Cloud Tasksに個別タスク生成ジョブを投入"""
    client = tasks_v2.CloudTasksClient()
    queue_name = 'task-generation-queue'
    parent = client.queue_path(PROJECT_ID, REGION, queue_name)

    worker_url = f"https://{REGION}-{PROJECT_ID}.cloudfunctions.net/personalized-tasks-worker"

    payload = json.dumps({
        'user_id': str(user_id),
        'line_user_id': line_user_id
    }).encode()

    task = {
        'http_request': {
            'http_method': tasks_v2.HttpMethod.POST,
            'url': worker_url,
            'headers': {'Content-Type': 'application/json'},
            'body': payload,
            'oidc_token': {
                'service_account_email': 'webhook-handler@uketsuguai-dev.iam.gserviceaccount.com'
            }
        }
    }

    response = client.create_task(request={'parent': parent, 'task': task})
    print(f"📤 個別タスク生成ジョブを投入: {response.name}")


def enqueue_tips_enhancement(user_id: str, line_user_id: str):
    """Cloud TasksにTips収集ジョブを投入"""
    client = tasks_v2.CloudTasksClient()
    queue_name = 'task-generation-queue'
    parent = client.queue_path(PROJECT_ID, REGION, queue_name)

    worker_url = f"https://{REGION}-{PROJECT_ID}.cloudfunctions.net/tips-enhancement-worker"

    payload = json.dumps({
        'user_id': str(user_id),
        'line_user_id': line_user_id
    }).encode()

    task = {
        'http_request': {
            'http_method': tasks_v2.HttpMethod.POST,
            'url': worker_url,
            'headers': {'Content-Type': 'application/json'},
            'body': payload,
            'oidc_token': {
                'service_account_email': 'webhook-handler@uketsuguai-dev.iam.gserviceaccount.com'
            }
        }
    }

    response = client.create_task(request={'parent': parent, 'task': task})
    print(f"📤 Tips収集ジョブを投入: {response.name}")
```

---

## 🚀 デプロイ

### Cloud Functionsデプロイ

```bash
# 既存のwebhookとtask-generator-workerを更新
gcloud functions deploy webhook \
  --gen2 \
  --runtime=python311 \
  --region=asia-northeast1 \
  --source=./02_src/webhook-handler \
  --entry-point=webhook \
  --trigger-http \
  --allow-unauthenticated

gcloud functions deploy task-generator-worker \
  --gen2 \
  --runtime=python311 \
  --region=asia-northeast1 \
  --source=./02_src/webhook-handler \
  --entry-point=generate_tasks_worker \
  --trigger-http \
  --no-allow-unauthenticated

# 新規: 個別タスク生成ワーカー
gcloud functions deploy personalized-tasks-worker \
  --gen2 \
  --runtime=python311 \
  --region=asia-northeast1 \
  --source=./02_src/webhook-handler \
  --entry-point=personalized_tasks_worker \
  --trigger-http \
  --no-allow-unauthenticated

# 新規: Tips収集ワーカー
gcloud functions deploy tips-enhancement-worker \
  --gen2 \
  --runtime=python311 \
  --region=asia-northeast1 \
  --source=./02_src/webhook-handler \
  --entry-point=tips_enhancement_worker \
  --trigger-http \
  --no-allow-unauthenticated
```

---

## ✅ テスト手順

### 1. ユニットテスト

```bash
pytest 04_tests/test_question_generator.py
pytest 04_tests/test_conversation_flow_manager.py
pytest 04_tests/test_task_personalizer.py
pytest 04_tests/test_task_enhancer.py
```

### 2. 統合テスト

1. LINEでbotを友だち追加
2. プロフィールを登録
3. 基本タスクが生成されることを確認
4. 追加質問が届くことを確認
5. すべての質問に回答
6. 個別タスクが生成されることを確認
7. Tipsが追加されることを確認

---

## 📊 モニタリング

### ログ確認

```bash
# Step 1ログ
gcloud functions logs read task-generator-worker --region=asia-northeast1 --limit=50

# Step 2ログ
gcloud functions logs read personalized-tasks-worker --region=asia-northeast1 --limit=50

# Step 3ログ
gcloud functions logs read tips-enhancement-worker --region=asia-northeast1 --limit=50
```

### ステータス確認クエリ

```sql
-- 各ステップの進捗確認
SELECT
  user_id,
  step_name,
  status,
  started_at,
  completed_at,
  metadata
FROM task_generation_steps
WHERE user_id = '<USER_ID>'
ORDER BY created_at DESC;

-- 追加質問の回答状況
SELECT
  question_text,
  is_answered,
  answer
FROM follow_up_questions
WHERE user_id = '<USER_ID>'
ORDER BY display_order;
```

---

## ⚠️ 注意事項

1. **API費用**: 3ステップに分割することで、Gemini APIの呼び出しが増加します。コストを監視してください。

2. **タイムアウト**: Cloud Functionsのタイムアウトを十分に設定してください（推奨: 600秒）。

3. **エラーハンドリング**: 各ステップで独立してエラーハンドリングを行い、1ステップの失敗が全体に影響しないようにしてください。

4. **キャッシング**: 基本タスクは自治体×関係性でキャッシュすることでAPI費用を削減できます（将来の最適化案）。

---

## 🔧 トラブルシューティング

### 問題: 追加質問が送信されない

**原因**: follow_up_questionsテーブルへの書き込みエラー

**解決**:
```sql
SELECT * FROM follow_up_questions WHERE user_id = '<USER_ID>';
```

### 問題: 個別タスクが生成されない

**原因**: すべての追加質問に回答していない

**解決**:
```sql
SELECT question_text, is_answered
FROM follow_up_questions
WHERE user_id = '<USER_ID>' AND is_answered = false;
```

### 問題: Tipsが追加されない

**原因**: Step 2が完了していない

**解決**:
```sql
SELECT * FROM task_generation_steps
WHERE user_id = '<USER_ID>' AND step_name = 'personalized';
```

---

## 📝 今後の改善案

1. **キャッシング機能**: 基本タスクのキャッシュ実装
2. **A/Bテスト**: 3ステップ vs 1ステップの効果測定
3. **質問の動的生成**: AIが基本タスクを見て追加質問を自動生成
4. **Tips品質フィルタ**: 収集したTipsの品質を評価してフィルタリング

---

## まとめ

この統合により、以下が実現されます：

✅ ユーザー固有の状況に完全に特化したタスク生成
✅ リアルな体験談・裏技の提供
✅ 不要なタスクの削減
✅ ユーザー満足度の向上

実装完了後、ユーザーフィードバックを収集し、継続的に改善していきます。
